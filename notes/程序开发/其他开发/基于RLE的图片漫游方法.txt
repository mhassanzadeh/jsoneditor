Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2010-04-29T18:34:24.831000

====== 基于RLE的图片漫游方法 ======
Created Thursday 29 April 2010

最近我在做一个嵌入式开发，其中一个功能需要实现像地图漫游那样的功能，但是硬件的内存小，不足以一次把整个图片读到内存中，所以只能一次次的把需要显示的部分读入到显存。在图像数据不压缩的情况下，只要在准备要移动在屏幕上显示的部分时，根据屏幕左上角确定 x，y 坐标，然后根据式子：

   data = ( x + DATA_w * y ) * LCD_w
   DATA_w 是图片的宽度，LCD_w 是屏幕宽度（固定的）

读取一行的图像数据写到显存中，然后根据 y 循环就可以显示完整个屏幕了。
   但是，这样的方式只有在数据不压缩的情况下才可以。未压缩之前，图像数据一个象素点是一个数据，所以每一行的数据长度都一样。但是如果图像数据压缩了，每一行的数据长度就不一定一样了。那么就没办法知道压缩过的数据之中从那里开始解压才合适，但是内存又不能容下一次性全部解压出来的图像数据。
   根据实际情况，我做的这个系统中使用的图片都是 256 色的，而且重复的地方也比较多，但是如果不压缩的话又会占掉很多的存储空间。所以最后决定使用 RLE 的方式来压缩。一方面算法简单，另一方面实现漫游的功能也比较容易。

   RLE 压缩之后，在每个关键字节那里都记录有解压后的数据长度（具体请参见 RLE 的压缩算法的描述）。所以，在制作压缩程序时，程序把图像数据压缩好之后，在额外建一个表，里面记录每一行压缩后的长度，保存在压缩好的图像数据之前。结构如下图：
    
   压缩后的数据 压缩后的长度
   xxxxxxx                     7
   xxx                           3
   xxxxxxxxxxxx            12
   xxxxxxxx                   8
   xxxx                          4

这样，在解压程序解压数据的时候就仍然可以使用类似压缩之前的方法来实现漫游功能。

   仍然以上表的数据为例，比如，当要显示第3行第6个开始的数据时。那么，这个数据之前的两行数据就有 7 + 3 个。因为 RLE 的关键字节中包含了紧接着的数据长度，所以这一行的第 6 个数据就很容易找到在什么位置了。比如第3行的数据具体是（16进制）：

   03 11 84 12 13 14 15 05 16 82 17 18
           ^----
第一个字节 0x03 表示接下去的 3 个解压后的字节用 0x11 填充，第 3 个字节 0x84 表示解压后的接下去的 4 个字节用 0x12 0x13 0x14 0x15 填充。那么我们的程序就可以知道应该从箭头处开始解压，可以先放到工作内存，然后把 0x14 之后的数据放到显存。依此类推可以把所有数据按需解压。

   这样，使用 RLE 实现图片的漫游，算法简单，解压速度和压缩比都不算小，在嵌入式系统上面实现容易。
